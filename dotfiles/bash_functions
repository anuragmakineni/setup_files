#!bin/bash
######################################################################
# This file is a collection of useful functions
# Here is a list of them
# overo
# rosmu
# rospp
# remake
######################################################################

# set ROS_MASTER_URI
function rosmu()
{
    # print current master uri if no inputs
    if [ $# -eq 0 ]; then
        rosmu_disp
        return 0
    fi

    # check command-lin options
    if [ -n "$(echo $1 | grep '^-')" ]; then
        case $1 in
            --help | -h )
                rosmu_help
                ;;
            * )
                echo "rosmu: $1: invalid option"
                rosmu_help
                ;;
        esac
        return 0
    fi

    cmd=$1
    local rx='([1-9]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])'
    case $cmd in
        set )
            if [ "$2" == "-h" ]; then
                echo -e "rosmu set set ROS_MASTER_URI to the given IP address"
                echo -e "usage: rosmu set 192.168.129.1"
            elif [[ ! $2 =~ ^$rx\.$rx\.$rx\.$rx$ ]]; then
                # validating IP address using regexp
                echo -e "rosmu: set: invalid IP address"
                echo -e "usage: rosmu set 192.168.129.1"
            else
                export ROS_MASTER_URI="http://$2:11311"
                rosmu_disp
            fi
            ;;
        reset )
            if [ "$2" == "-h" ]; then
                echo -e "rosmu reset reset ROS_MASTER_URI to local host"
                echo -e "usage: rosmu reset"
            else
                export ROS_MASTER_URI="http://localhost:11311"
                rosmu_disp
            fi
            ;;
        * )
            echo "rosmu: $1: invalid command"
            rosmu_help
            ;;
    esac
}

function rosmu_disp()
{
    echo -e "${bldylw}ROS_MASTER_URI$txtrst"
    echo -e "${bldgrn}$ROS_MASTER_URI$txtrst"
    return 0
}

function rosmu_help()
{
    echo -e "rosmu is a command-line tool for managing ROS_MASTER_URI"
    echo -e "usage: rosmu [--help|-h] <command> [<args>]\n"
    echo -e "The most commonly used rosmu commands are:"
    echo -e "    set   \tSet ROS_MASTER_URI to the given IP address"
    echo -e "    reset \tReset ROS_MASTER_URI to localhost"
    echo -e "\nType rosmu <command> -h for more detailed usage, e.g. 'ros set -h'\n"
    return 0
}
# rospp manages ROS_PACKAGE_PATH
# Initialize variables
if [ -z $ROSPP_DEFAULT ]; then
    declare -rx ROSPP_DEFAULT=$ROS_PACKAGE_PATH
fi
export ROSPP_STACK=${ROSPP_STACK:-$ROS_PACKAGE_PATH}
ROS_PACKAGE_PATH=$ROSPP_STACK

# main function of rospp
function rospp()
{
    # print current path if no inputs
    if [ $# -eq 0 ]; then
        rospp_disp
        return 0
    fi

    # check command-line options
    if [ -n "$(echo $1 | grep '^-')" ]; then
        case $1 in
            --help | -h )
                rospp_help
                ;;
            * )
                echo "rospp: $1: invalid option"
                rospp_help
                ;;
        esac
        return 0
    fi

    # check command-line commands
    cmd=$1
    case $cmd in
        reset )
            if [ "$2" == "-h" ]; then
                echo -e "rospp reset set ROS_PACKAGE_PATH to its default value"
                echo -e "usage: rospp reset"
            else
                ROSPP_STACK=$ROSPP_DEFAULT
                ROS_PACKAGE_PATH=$ROSPP_STACK
                rospp_disp
            fi
            ;;
        push )
            if [ "$2" == "-h" ]; then
                echo -e "usage: rospp push [dir]"
            else
                rospp_push "$2"
                rospp_disp
            fi
            ;;
        pop )
            if [ "$2" == "-h" ]; then
                echo -e "usage: rospp pop"
            else
                rospp_pop
                rospp_disp
            fi
            ;;
        disp )
            if [ "$2" == "-h" ]; then
                echo -e "usage: rospp disp"
            else
                rospp_disp
            fi
            ;;
        * )
            echo "rospp: $1: invalid command"
            rospp_help
            ;;
    esac
    return 0
}

# display ROS_PACKAGE_PATH
function rospp_disp()
{
    echo -e "${bldylw}ROS_PACKAGE_PATH$txtrst"
    rospp_split $ROS_PACKAGE_PATH
    return 0
}

# print help contents for rospp
function rospp_help()
{
    echo -e "rospp is a command-line tool for managing ROS_PACKAGE_PATH"
    echo -e "usage: rospp [--help|-h] <command> [<args>]\n"
    echo -e "The most commonly used rospp commands are:"
    echo -e "    push \tPush directory to ROS_PACKAGE_PATH and cd to it"
    echo -e "    pop  \tPop top directory from ROS_PACKAGE_PATH"
    echo -e "    reset\tReset ROS_PACKAGE_PATH"
    echo -e "    add  \tAdd directory to ROS_PACKAGE_PATH"
    echo -e "    rm   \tRemove path from ROS_PACKAGE_PATH"
    echo -e "    disp \tDisplay all ROS_PACKAGE_PATH"
    echo -e "\nType rospp <command> -h for more detailed usage, e.g. 'rospp push -h'\n"
    return 0
}

# rospp push
function rospp_push()
{
    local dir=${1:-$PWD}
    if [ \( -d $dir \) -a \( -x $dir \) ]; then
        ROSPP_STACK="$ROSPP_STACK:$dir"
        ROS_PACKAGE_PATH=$ROSPP_STACK
    else
        echo "rospp: push: invalid directory"
    fi
    return 0
}

# rospp pop
function rospp_pop()
{
    # append : to the beginning stack
    local stack=:$ROSPP_STACK
    if [ ! $stack == ":" ]; then
        # remove the last path in stack
        ROSPP_STACK=${stack%:*}
        # remove the beginning colon
        ROSPP_STACK=${ROSPP_STACK#:}
        ROS_PACKAGE_PATH=$ROSPP_STACK
    else
        echo "ROS_PACKAGE_PATH empty"
    fi
    return 0
}

# split string with : as delimeter
function rospp_split()
{
    # append : to the end of pathlist
    pathlist=$1:
    i=0
    while [ $pathlist ]; do
        if [ ! $pathlist == ":" ]; then
            echo -e "$bldgrn$((++i)): ${pathlist%%:*}$txtrst"
        fi
        # remove the first path
        pathlist=${pathlist#*:}
    done
    return 0
}

# rerun make in build folder
function remake()
{
    make -C ./build
}
